<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Arash â€” Fullpage Visual Playground</title>
<style>
/* ====================================================
   Arash Fullpage Visual Playground (single-file)
   - Fullscreen interactive canvas
   - Mouse-aim cannon, charged shots, targets, particle FX
   - Floating glass calculator (draggable)
   - Dark/glow aesthetic tuned to your site
   ==================================================== */

/* Root colors & small reset */
:root{
  --bg-top: #98d7ff;
  --bg-mid: #7ec7ff;
  --bg-bot: #4b7bec;
  --accent1: #6dd3ff;
  --accent2: #6b9bff;
  --glow: rgba(255,255,255,0.12);
  --glass: rgba(255,255,255,0.06);
  --glass-border: rgba(255,255,255,0.08);
  --text: #eef6ff;
}
*{box-sizing:border-box}
html,body{height:100%; margin:0; overflow:hidden; font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
body{background:linear-gradient(180deg,var(--bg-top),var(--bg-mid),var(--bg-bot)); color:var(--text); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale}

/* root container */
#root {
  position: relative;
  width:100%;
  height:100vh;
  overflow:hidden;
}

/* Top-left controls */
.topbar {
  position: absolute;
  left: 18px;
  top: 18px;
  display:flex;
  gap:10px;
  align-items:center;
  z-index:190;
}
.btn {
  background: linear-gradient(180deg,var(--accent1),var(--accent2));
  color:#04102a;
  border:none;
  padding:10px 14px;
  border-radius:10px;
  cursor:pointer;
  font-weight:700;
  font-size:13px;
  box-shadow: 0 8px 28px rgba(10,20,40,0.25);
}
.btn.secondary{
  background:transparent;
  color:var(--text);
  border:1px solid rgba(255,255,255,0.08);
  box-shadow:none;
}

/* HUD */
.hud {
  position:absolute;
  right:18px;
  top:18px;
  z-index:190;
  display:flex;
  gap:12px;
  align-items:center;
}
.hud .score {
  background: rgba(0,0,0,0.22);
  padding:8px 12px;
  border-radius:10px;
  color:var(--text);
  font-weight:700;
  box-shadow:0 6px 18px rgba(0,0,0,0.3);
}

/* greeting center top */
.greeting {
  position:absolute;
  left:50%;
  top:6%;
  transform:translateX(-50%);
  text-align:center;
  pointer-events:none;
  z-index:160;
}
.greeting h1{
  margin:0;
  font-size:28px;
  color:var(--text);
  text-shadow:0 8px 30px rgba(0,0,0,0.3);
}
.greeting p{margin:6px 0 0 0; color: rgba(255,255,255,0.9); font-size:13px}

/* cursor glow: DOM element */
#cursorGlow {
  position: fixed;
  width: 140px;
  height: 140px;
  border-radius: 50%;
  pointer-events: none;
  background: radial-gradient(circle at 40% 30%, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.25) 12%, rgba(255,255,255,0.06) 30%, transparent 60%);
  filter: blur(30px);
  opacity: 0.85;
  transform: translate(-9999px,-9999px);
  z-index:170;
  transition: transform .05s linear;
}

/* night overlay to dim the scene at idle */
.night-overlay {
  position:absolute;
  left:0; top:0; right:0; bottom:0;
  background: linear-gradient(180deg, rgba(0,0,40,0) 0%, rgba(2,6,12,0.35) 100%);
  pointer-events:none;
  z-index:120;
  transition:opacity 1s ease;
  opacity:0;
}

/* calculator (glass panel) - draggable */
.calculator {
  position:absolute;
  right:22px;
  top:120px;
  width:320px;
  background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
  border-radius:12px;
  border: 1px solid var(--glass-border);
  padding:12px;
  box-shadow: 0 18px 40px rgba(3,10,20,0.45);
  z-index:195;
  backdrop-filter: blur(10px) saturate(120%);
  cursor: grab;
}
.calculator.dragging { cursor:grabbing; }
.calc-head { display:flex; justify-content:space-between; align-items:center; gap:10px; }
.calc-title { font-weight:800; color:var(--text) }
.calc-close { background:transparent; border:1px solid rgba(255,255,255,0.06); padding:6px 8px; color:var(--text); border-radius:8px; cursor:pointer }
.calc-screen { margin-top:8px; height:56px; border-radius:10px; background:rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:flex-end; padding:8px 12px; font-size:22px; color:var(--text); box-shadow: inset 0 -6px 18px rgba(0,0,0,0.3) }
.calc-keys { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; margin-top:10px; }
.key { padding:12px; border-radius:8px; border:none; cursor:pointer; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); color:var(--text); font-weight:700; box-shadow: 0 8px 18px rgba(0,0,0,0.25); }
.key.op { background:linear-gradient(180deg,#57d4a8,#3bc48d); color:#041026 }
.key.clear { background:linear-gradient(180deg,#ff6b6b,#ff5a5a); color:white; grid-column: span 2; }

/* small help note bottom-left */
.note {
  position:absolute;
  left:18px;
  bottom:18px;
  color:rgba(255,255,255,0.9);
  z-index:180;
  font-size:13px;
  text-shadow:0 2px 6px rgba(0,0,0,0.25);
}

/* canvas style & placement */
canvas {
  display:block;
  position:absolute;
  left:50%;
  bottom:40px;
  transform:translateX(-50%);
  z-index:100;
  border-radius:12px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.25);
}

/* responsive tweaks */
@media (max-width:860px){
  .calculator{ right:12px; width:260px; top:100px }
  .hud{ display:none }
  .greeting h1{ font-size:20px }
}

/* small accessibility focus ring for buttons */
.btn:focus, .key:focus, .calc-close:focus { outline:2px solid rgba(255,255,255,0.06); outline-offset:2px; }
</style>
</head>
<body>
  <div id="root">

    <!-- Top bar controls -->
    <div class="topbar">
      <button class="btn" id="toggleCalcBtn">Toggle Calculator (C)</button>
      <button class="btn secondary" id="toggleTargetsBtn">Toggle Targets</button>
      <button class="btn secondary" id="clearBallsBtn">Clear Balls</button>
      <button class="btn secondary" id="resetBtn">Reset Scene</button>
    </div>

    <!-- HUD: score -->
    <div class="hud">
      <div class="score">Score: <span id="scoreValue">0</span></div>
    </div>

    <!-- Center greeting -->
    <div class="greeting">
      <h1>Hello, I'm Arash ðŸ‘‹</h1>
      <p>Move your mouse to aim the cannon â€” hold to charge, release to fire. Press Space to shoot. Enjoy the visuals.</p>
    </div>

    <!-- cursor glow -->
    <div id="cursorGlow" aria-hidden="true"></div>

    <!-- night overlay -->
    <div class="night-overlay" id="nightOverlay"></div>

    <!-- note -->
    <div class="note">Tip: Click empty space to shoot. Don't click UI â€” it won't fire.</div>

    <!-- floating calculator (draggable) -->
    <div class="calculator" id="calculator" role="dialog" aria-label="Calculator">
      <div class="calc-head">
        <div class="calc-title">Calculator</div>
        <div style="display:flex;gap:8px;align-items:center">
          <button class="calc-close" id="hideCalcBtn">Hide</button>
        </div>
      </div>
      <div class="calc-screen" id="calcScreen">0</div>
      <div class="calc-keys" id="calcKeys">
        <button class="key" data-key="7">7</button>
        <button class="key" data-key="8">8</button>
        <button class="key" data-key="9">9</button>
        <button class="key" data-key="/">Ã·</button>

        <button class="key" data-key="4">4</button>
        <button class="key" data-key="5">5</button>
        <button class="key" data-key="6">6</button>
        <button class="key" data-key="*">Ã—</button>

        <button class="key" data-key="1">1</button>
        <button class="key" data-key="2">2</button>
        <button class="key" data-key="3">3</button>
        <button class="key" data-key="-">âˆ’</button>

        <button class="key" data-key="0">0</button>
        <button class="key" data-key=".">.</button>
        <button class="key op" data-key="=">=</button>
        <button class="key" data-key="+">+</button>

        <button class="key clear" data-key="C">Clear</button>
        <button class="key" data-key="H">Home</button>
      </div>
    </div>

    <!-- main canvas -->
    <canvas id="mainCanvas" width="1100" height="520" aria-label="Interactive playground"></canvas>

  </div>

<script>
/* ============================
   Interactive Playground Script
   Author: ChatGPT (for Arash)
   Features:
     - responsive hi-dpi canvas
     - parallax background layers
     - fireflies / particles
     - cannon aiming at mouse; hold to charge; release to shoot
     - targets that move and pop for score
     - explosion & spark particles
     - floating glass calculator (draggable) with basic functionality
     - night-mode fade on idle
   ============================ */

(() => {
  // ---------- Helpers ----------
  const rand = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const now = () => performance.now();

  // ---------- DOM refs ----------
  const canvas = document.getElementById('mainCanvas');
  const ctx = canvas.getContext('2d');
  const root = document.getElementById('root');
  const cursorGlow = document.getElementById('cursorGlow');
  const nightOverlay = document.getElementById('nightOverlay');
  const calcEl = document.getElementById('calculator');
  const toggleCalcBtn = document.getElementById('toggleCalcBtn');
  const hideCalcBtn = document.getElementById('hideCalcBtn');
  const toggleTargetsBtn = document.getElementById('toggleTargetsBtn');
  const clearBallsBtn = document.getElementById('clearBallsBtn');
  const resetBtn = document.getElementById('resetBtn');
  const scoreSpan = document.getElementById('scoreValue');

  // DPR for crisp canvas
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // ---------- State ----------
  let W = 1100, H = 520;
  let mouse = { x: W/2, y: H/2, down:false, holdingSince:0 };
  let lastMoveTS = Date.now();
  let idleStart = Date.now();
  let balls = [];
  let particles = [];
  let fireflies = [];
  let targets = [];
  let showTargets = true;
  let score = 0;
  let lastFrame = now();

  // cannon
  let cannon = { x: W/2, y: H - 60, angle: -Math.PI/4, length: 56, radius: 20 };

  // physics tuning
  const physics = {
    gravity: 0.5,
    frictionGround: 0.82,
    bounce: 0.62
  };

  // ---------- Canvas resize ----------
  function resize() {
    const maxW = Math.min(window.innerWidth - 80, 1400);
    const computedW = Math.max(700, maxW);
    const computedH = Math.min(720, Math.max(420, window.innerHeight - 180));
    W = Math.floor(computedW);
    H = Math.floor(computedH);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    // reposition cannon
    cannon.x = W/2;
    cannon.y = H - 60;
  }

  // ---------- Entities ----------
  function createBall(x,y,vx,vy,r,color){
    return { x,y,vx,vy,r,color,trail:[],age:0,settle:0 };
  }

  function createParticle(x,y,vx,vy,life,r,color,fade=true){
    return { x,y,vx,vy,life,age:0,r,color,fade };
  }

  function createTarget(x,y,rx=28,ry=28, vx=0.5, vy=0, color='#ffd6f5'){
    return { x,y,rx,ry,vx,vy,alive:true,color,health:1 + Math.floor(rand(0,2)) };
  }

  // ---------- Init scene ----------
  function initFireflies(n=28){
    fireflies = [];
    for(let i=0;i<n;i++){
      fireflies.push({
        x: rand(40,W-40),
        y: rand(40,H/2),
        r: rand(1.5,3.5),
        speed: rand(0.02,0.12),
        phase: rand(0,Math.PI*2),
        hue: rand(160,330),
        drift: rand(-0.12,0.12)
      });
    }
  }

  function initTargets(n=6){
    targets = [];
    for(let i=0;i<n;i++){
      const x = rand(120, W-120);
      const y = rand(80, H/2);
      const t = createTarget(x,y, rand(18,36), rand(18,36), rand(-0.5,0.5), 0, `hsl(${rand(0,360)},85%,65%)`);
      targets.push(t);
    }
  }

  // ---------- Update physics ----------
  function update(dt){
    // dt normalized (frame independent)
    // update balls
    for(let i=balls.length-1;i>=0;i--){
      const b = balls[i];
      b.vy += physics.gravity * dt;
      b.vx *= (1 - 0.001*dt);
      b.vy *= (1 - 0.0009*dt);
      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.age += dt;

      // append trail
      if(b.age % 2 < 0.9) b.trail.push({ x:b.x, y:b.y, t: 60 });
      if(b.trail.length > 24) b.trail.shift();

      // ground collision
      if(b.y + b.r > H - 20){
        b.y = H - 20 - b.r;
        b.vy *= -physics.bounce;
        b.vx *= physics.frictionGround;
        // small explosion sparks & smoke
        spawnExplosion(b.x, H - 20, Math.floor(rand(6,12)));
        // if speed small, start settling
        if(Math.abs(b.vy) < 0.8 && Math.abs(b.vx) < 0.6){
          b.vx *= 0.2;
          b.vy = 0;
          b.settle += dt;
          if(b.settle > 600){
            // fade / pop & remove
            spawnExplosion(b.x, b.y, 8);
            balls.splice(i,1);
            continue;
          }
        }
      }

      // remove off-screen
      if(b.x < -200 || b.x > W + 200 || b.y > H + 200) balls.splice(i,1);
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vy += 0.12 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.age += dt;
      if(p.age > p.life) particles.splice(i,1);
    }

    // update fireflies
    for(let f of fireflies){
      f.phase += f.speed * dt * 0.06;
      f.x += f.drift * dt;
      f.y += Math.sin(f.phase) * f.speed * 0.6 * dt;
      if(f.x < 20) f.x = W - 40;
      if(f.x > W - 20) f.x = 40;
    }

    // update targets (move horizontally)
    for(let t of targets){
      if(!t.alive) continue;
      t.x += t.vx * dt;
      // bounce edges
      if(t.x < 40 || t.x > W - 40) t.vx *= -1;
      // small bobbing
      t.y += Math.sin((t.x + Date.now()*0.001) * 0.006) * 0.2;
    }

    // fade trails
    for(let b of balls){
      for(let j=b.trail.length-1;j>=0;j--){
        b.trail[j].t -= dt;
        if(b.trail[j].t <= 0) b.trail.splice(j,1);
      }
    }
  }

  // ---------- Spawning ----------

  function spawnBall(power=12){
    const ang = cannon.angle;
    const sx = cannon.x + Math.cos(ang) * (cannon.length + 8);
    const sy = cannon.y + Math.sin(ang) * (cannon.length + 8);
    const speed = power * (0.9 + Math.random()*0.3);
    const vx = Math.cos(ang) * speed + rand(-0.6,0.6);
    const vy = Math.sin(ang) * speed + rand(-0.6,0.6);
    const col = ['#ffffff','#fff7e6','#bff7ff','#ffd6f5','#b9ffde'][Math.floor(rand(0,5))];
    balls.push(createBall(sx, sy, vx, vy, rand(8,12), col));
    // muzzle particles
    for(let i=0;i<8;i++){
      const a = ang + rand(-0.5,0.5);
      const s = rand(1.4,5.6);
      particles.push(createParticle(sx, sy, Math.cos(a)*s, Math.sin(a)*s, 36 + Math.random()*30, rand(1,3), '#ffd6a8'));
    }
  }

  function spawnExplosion(x,y,count=20){
    for(let i=0;i<count;i++){
      const ang = rand(0,Math.PI*2);
      const speed = rand(1.6,6.2);
      particles.push(createParticle(x, y, Math.cos(ang)*speed, Math.sin(ang)*speed, 30+Math.random()*30, rand(1,3), `hsl(${rand(20,60)},95%,65%)`));
    }
  }

  function spawnTargetPop(x,y){
    // score and big particles
    score += 10;
    scoreSpan.textContent = score;
    spawnExplosion(x, y, 40);
  }

  // ---------- Drawing ----------

  function clearCanvas(){
    ctx.clearRect(0,0,W,H);
  }

  function drawBackground(tMix){
    // tMix 0..1 for day->night
    const top = lerpColor('#bfe9ff','#14203b', tMix);
    const mid = lerpColor('#83d6ff','#0b1c3a', tMix*0.9);
    const bot = lerpColor('#6aa9ff','#071027', tMix*0.8);
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, top);
    g.addColorStop(0.45, mid);
    g.addColorStop(1, bot);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // soft blobs for depth (parallax)
    for(let i=0;i<3;i++){
      ctx.save();
      ctx.globalAlpha = 0.06 + i*0.02;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      softBlob(W*0.5 + Math.sin(tMix*10 + i)*40 + (mouse.x-W/2)*0.01*(i+1), 60 + i*40, 420 + i*120, 120 + i*40, 6+i*2);
      ctx.restore();
    }
  }

  function softBlob(ox, oy, w, h, steps){
    for(let s=0;s<steps;s++){
      const a = 1 - s/steps;
      ctx.beginPath();
      ctx.ellipse(ox + Math.sin(s)*12, oy + Math.cos(s)*8, w*(0.85 - s/steps*0.5), h*(0.9 - s/steps*0.6), 0, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${0.06*a})`;
      ctx.fill();
    }
  }

  function drawFireflies(){
    for(let f of fireflies){
      // glow
      const grad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, 30);
      grad.addColorStop(0, `hsla(${f.hue},95%,70%,0.95)`);
      grad.addColorStop(0.3, `hsla(${f.hue},95%,60%,0.4)`);
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r*5 + Math.abs(Math.sin(f.phase))*6, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  function drawGroundAndFog(){
    const groundH = 36;
    const gy = H - groundH;
    const grd = ctx.createLinearGradient(0, gy, 0, H);
    grd.addColorStop(0, 'rgba(12,19,35,0.16)');
    grd.addColorStop(1, 'rgba(6,9,18,0.8)');
    ctx.fillStyle = grd;
    ctx.fillRect(0, gy, W, groundH);

    ctx.globalAlpha = 0.12;
    softBlob(W/2, gy + 8, W*0.7, 60, 5);
    ctx.globalAlpha = 1;
  }

  function drawCannon(){
    // compute angle toward mouse
    const target = Math.atan2(mouse.y - cannon.y, mouse.x - cannon.x);
    // keep barrel above ground: clamp roughly between -pi+0.6 and -0.2
    const minA = -Math.PI + 0.3;
    const maxA = -0.18;
    let clamped = target;
    if(clamped < -Math.PI) clamped += Math.PI*2;
    clamped = Math.max(minA, Math.min(maxA, clamped));
    // smooth rotation
    cannon.angle += (clamped - cannon.angle) * 0.18;

    // barrel
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    ctx.rotate(cannon.angle);

    // shadow under barrel
    ctx.fillStyle = '#0c1624';
    roundRect(ctx, -8, -14, cannon.length + 36, 30, 14);
    ctx.fill();

    // barrel glossy gradient
    const g = ctx.createLinearGradient(0, -12, cannon.length + 36, 12);
    g.addColorStop(0, '#1f2b39');
    g.addColorStop(0.6, '#476b82');
    g.addColorStop(1, '#0b1220');
    ctx.fillStyle = g;
    roundRect(ctx, -6, -12, cannon.length + 26, 24, 12);
    ctx.fill();

    // muzzle ring
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.06;
    roundRect(ctx, cannon.length + 8, -10, 18, 20, 8);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();

    // base discs
    ctx.beginPath();
    ctx.fillStyle = '#0b1420';
    ctx.arc(cannon.x, cannon.y, cannon.radius + 10, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle = '#091018';
    ctx.arc(cannon.x, cannon.y, cannon.radius, 0, Math.PI*2);
    ctx.fill();

    // highlight ring
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.arc(cannon.x, cannon.y, cannon.radius+6, 0, Math.PI*2);
    ctx.stroke();
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawBalls(){
    for(const b of balls){
      // trail
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(const t of b.trail){
        const alpha = clamp(t.t/60,0,1) * 0.42;
        const rr = Math.max(1.6, (t.t/60)*6);
        const grad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, rr*4);
        grad.addColorStop(0, hexToRgba(b.color, alpha));
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(t.x,t.y, rr, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // ball
      ctx.beginPath();
      ctx.fillStyle = b.color;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 26;
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  function drawParticles(){
    for(const p of particles){
      const alpha = 1 - (p.age / p.life);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(0.6, p.r * (1 - p.age/p.life)), 0, Math.PI*2);
      ctx.fill();

      // glow
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = hexToRgba(p.color, alpha*0.18);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*6, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1;
    }
  }

  function drawTargets(){
    for(const t of targets){
      if(!t.alive) continue;
      // body
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.beginPath();
      ctx.fillStyle = t.color;
      ctx.shadowColor = t.color;
      ctx.shadowBlur = 14;
      ctx.ellipse(0,0, t.rx, t.ry, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // ring
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.lineWidth = 1.4;
      ctx.ellipse(0,0, t.rx*1.08, t.ry*1.08, 0, 0, Math.PI*2);
      ctx.stroke();

      // small health marker
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      ctx.beginPath();
      ctx.ellipse(-t.rx*0.3, -t.ry*0.6, Math.max(2, t.rx*0.18), Math.max(2, t.ry*0.12), 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  // ---------- Utility drawing helpers ----------
  function lerpColor(a,b,t){
    const ca = hexToRgb(a), cb = hexToRgb(b);
    const r = Math.round(ca.r + (cb.r - ca.r) * t);
    const g = Math.round(ca.g + (cb.g - ca.g) * t);
    const bl = Math.round(ca.b + (cb.b - ca.b) * t);
    return `rgb(${r},${g},${bl})`;
  }
  function hexToRgb(hex){
    const c = hex.replace('#','');
    const i = parseInt(c,16);
    return { r:(i>>16)&255, g:(i>>8)&255, b:i&255 };
  }
  function hexToRgba(hex, a=1){
    const c = hex.replace('#','');
    const i = parseInt(c,16);
    const r=(i>>16)&255, g=(i>>8)&255, b=i&255;
    return `rgba(${r},${g},${b},${a})`;
  }

  // ---------- Main loop ----------
  let last = now();
  let frameCount = 0;
  function loop(ts){
    const tNow = now();
    const rawDt = tNow - last;
    const dt = Math.min(40, rawDt) / (1000/60); // normalized to ~60fps scale (dt ~1 per frame)
    last = tNow;
    frameCount++;

    // idle/nightrise logic
    const idle = (Date.now() - lastMoveTS);
    const nightTarget = clamp((idle - 6000) / 10000, 0, 1); // starts after 6s, full ~16s
    nightOverlay.style.opacity = (nightTarget * 0.85).toString();

    // update physics
    update(dt);

    // draw background with night mix
    drawBackground(nightTarget);

    // ground & fog
    drawGroundAndFog();

    // fireflies
    drawFireflies();

    // particles then balls then targets (z-order adjusted)
    drawParticles();
    drawBalls();
    drawTargets();

    // cannon over everything
    drawCannon();

    // HUD & other effects (cursor handled by DOM element)

    requestAnimationFrame(loop);
  }

  // ---------- Input handling ----------
  function attachInput(){
    // mouse move -> map to canvas coords
    window.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      // Map to canvas coordinate system
      const cx = (e.clientX - rect.left) * (canvas.width / rect.width) / DPR;
      const cy = (e.clientY - rect.top) * (canvas.height / rect.height) / DPR;
      mouse.x = clamp(cx, 0, W);
      mouse.y = clamp(cy, 0, H);
      lastMoveTS = Date.now();

      // Move cursor glow DOM element
      cursorGlow.style.transform = `translate(${e.clientX - 70}px, ${e.clientY - 70}px)`;
    });

    // shoot on click (but avoid UI elements)
    window.addEventListener('click', (e) => {
      const target = e.target;
      // if clicked inside UI, don't shoot
      if(target.closest && (target.closest('.calculator') || target.closest('.topbar') || target.closest('.btn') || target.closest('.key'))) return;
      // if clicked on canvas area -> spawn ball
      spawnBallFromInput();
    });

    // mousedown & mouseup for charging
    window.addEventListener('mousedown', (e) => {
      const target = e.target;
      if(target.closest && (target.closest('.calculator') || target.closest('.topbar') || target.closest('.btn') || target.closest('.key'))) return;
      mouse.down = true;
      mouse.holdingSince = Date.now();
    });
    window.addEventListener('mouseup', (e) => {
      if(mouse.down){
        spawnBallFromInput();
      }
      mouse.down = false;
      mouse.holdingSince = 0;
    });

    // keyboard: space to shoot, c to toggle calc
    window.addEventListener('keydown', (e) => {
      if(e.key === ' '){
        e.preventDefault();
        spawnBallFromInput(13);
      } else if(e.key === 'c' || e.key === 'C'){
        toggleCalc();
      }
    });

    // resize
    window.addEventListener('resize', resize);
  }

  function spawnBallFromInput(forceOverride){
    // if clicking while holding we compute hold time
    let power = 12;
    if(forceOverride) power = forceOverride;
    else if(mouse.holdingSince){
      const hold = clamp((Date.now() - mouse.holdingSince), 0, 1200); // up to 1.2s
      power = 10 + (hold/1200) * 20;
    }
    spawnBall(power);
  }

  // ---------- Collisions (ball with targets) ----------
  function handleCollisions(){
    for(let i=balls.length-1;i>=0;i--){
      const b = balls[i];
      for(let j=targets.length-1;j>=0;j--){
        const t = targets[j];
        if(!t.alive) continue;
        // ellipse-hit test: transform point into target local coords
        const dx = b.x - t.x;
        const dy = b.y - t.y;
        const nx = dx / t.rx;
        const ny = dy / t.ry;
        if((nx*nx + ny*ny) <= 1){
          // hit!
          t.health -= 1;
          // spawn spark at impact
          spawnExplosion(b.x, b.y, 18);
          // knockback target a bit
          t.vx += (b.vx * 0.05);
          // remove the ball with small pop
          balls.splice(i,1);
          if(t.health <= 0){
            t.alive = false;
            spawnTargetPop(t.x, t.y);
            // small score multiplier / combos can be added
          } else {
            // small color / wiggle
            t.color = shadeColor(t.color, -8);
          }
          break;
        }
      }
    }
  }

  // helper to slightly darken hex color
  function shadeColor(hex, percent){
    // convert hsl fallback for random colors - but if hex provided, work naive
    try {
      const c = hex.replace('#','');
      const i = parseInt(c,16);
      let r = (i>>16)&255, g=(i>>8)&255, b=i&255;
      r = Math.round(r * (100+percent)/100);
      g = Math.round(g * (100+percent)/100);
      b = Math.round(b * (100+percent)/100);
      r = clamp(r,0,255); g = clamp(g,0,255); b = clamp(b,0,255);
      return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
    } catch(e) {
      return hex;
    }
  }

  // ---------- Particle and spawn helpers ----------
  function spawnExplosion(x,y,count=28){
    for(let k=0;k<count;k++){
      const ang = rand(0,Math.PI*2);
      const sp = rand(1.4,6.2);
      const col = `hsl(${rand(25,70)},95%,65%)`;
      particles.push(createParticle(x, y, Math.cos(ang)*sp, Math.sin(ang)*sp, 50 + Math.random()*30, rand(1,3), col));
    }
  }

  function createParticle(x,y,vx,vy,life,r,color){
    return { x,y,vx,vy,life,age:0,r,color };
  }

  // ---------- Calculator logic (simple) ----------
  let calcValue = '';
  function pressCalcKey(k){
    if(k === 'C'){ calcValue = ''; updateCalcScreen(); return; }
    if(k === 'H'){ calcValue = ''; updateCalcScreen(); return; }
    if(k === '='){
      try {
        const expr = calcValue.replace(/Ã—/g,'*').replace(/Ã·/g,'/');
        // use Function to avoid direct eval in some contexts
        const res = Function('"use strict"; return (' + expr + ')')();
        calcValue = String(res);
      } catch(e){
        calcValue = 'Error';
      }
      updateCalcScreen();
      return;
    }
    calcValue += k;
    updateCalcScreen();
  }
  function updateCalcScreen(){
    document.getElementById('calcScreen').textContent = calcValue === '' ? '0' : calcValue;
  }

  // ---------- Calculator dragging ----------
  (function setupCalcDrag(){
    let dragging = false;
    let startX=0, startY=0, elX=0, elY=0;
    const el = calcEl;
    el.addEventListener('mousedown', (e)=>{
      // only drag when clicking near header (calc-head)
      const rect = el.getBoundingClientRect();
      const localY = e.clientY - rect.top;
      if(localY > 0 && localY < 56){
        dragging = true;
        el.classList.add('dragging');
        startX = e.clientX; startY = e.clientY;
        elX = rect.left; elY = rect.top;
        document.body.style.userSelect = 'none';
      }
    });
    window.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const nx = elX + dx;
      const ny = elY + dy;
      el.style.left = nx + 'px';
      el.style.top = ny + 'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(dragging){
        dragging = false;
        el.classList.remove('dragging');
        document.body.style.userSelect = 'auto';
      }
    });
  })();

  // ---------- Buttons and UI ----------
  toggleCalcBtn.addEventListener('click', toggleCalc);
  hideCalcBtn.addEventListener('click', () => { calcEl.style.display = 'none'; });
  toggleTargetsBtn.addEventListener('click', () => {
    showTargets = !showTargets;
    if(showTargets) { initTargets(6); } else { targets = []; }
  });
  clearBallsBtn.addEventListener('click', () => { balls = []; particles = []; });
  resetBtn.addEventListener('click', () => { resetScene(); });

  // calculator keybinding
  document.getElementById('calcKeys').addEventListener('click', (e)=>{
    const k = e.target.closest('.key');
    if(!k) return;
    const key = k.getAttribute('data-key');
    if(!key) return;
    if(key === '=') pressCalcKey('=');
    else pressCalcKey(key);
  });

  function toggleCalc(){ calcEl.style.display = (calcEl.style.display === 'none') ? 'block' : 'none'; }

  // ---------- Reset & init ----------
  function resetScene(){
    balls = [];
    particles = [];
    score = 0;
    scoreSpan.textContent = score;
    initFireflies(32);
    if(showTargets) initTargets(6);
  }

  // ---------- Utility helpers ----------
  function spawnTargetPop(x,y){
    score += 10;
    scoreSpan.textContent = score;
    spawnExplosion(x,y,40);
  }

  // ---------- Collision scheduler (regular) ----------
  setInterval(() => {
    // run collision checks in interval to reduce per-frame overhead
    handleCollisions();
  }, 50);

  // ---------- Startup ----------
  function start(){
    resize();
    initFireflies(32);
    if(showTargets) initTargets(6);
    attachInput();
    last = now();
    requestAnimationFrame(loop);
  }

  // initialize & attach input
  attachInput();
  start();

  // expose some functions to console for debug
  window.__arash = { balls, particles, targets, resetScene, spawnBall, score: () => score };

  /* ------------- End IIFE ------------- */
})();

</script>
</body>
</html>
