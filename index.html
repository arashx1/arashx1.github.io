<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Arash â€” Visual & Interaction Playground</title>
<style>
  /* -------------------------
     Basic reset and layout
     ------------------------- */
  :root{
    --glass-bg: rgba(255,255,255,0.08);
    --glass-border: rgba(255,255,255,0.12);
    --accent: #6dd3ff;
    --accent-2: #6b9bff;
    --dark: #0b1220;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#081226;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial}
  body{overflow:hidden; color:#eef2ff}

  /* container for canvas & UI */
  #root {
    position:relative;
    width:100%;
    height:100vh;
    display:block;
    overflow:hidden;
    background: linear-gradient(180deg, #98d7ff 0%, #7ec7ff 35%, #4b7bec 100%);
    transition: background 1.2s ease;
  }

  /* top-left controls */
  .topbar {
    position:absolute;
    left:18px;
    top:18px;
    display:flex;
    gap:10px;
    align-items:center;
    z-index:30;
    pointer-events:auto;
  }
  .btn {
    background:linear-gradient(180deg,var(--accent),var(--accent-2));
    color:#061126;
    border:none;
    padding:10px 14px;
    border-radius:10px;
    box-shadow:0 6px 18px rgba(30,45,80,0.25);
    cursor:pointer;
    font-weight:600;
    font-size:14px;
    transition:transform .12s ease, box-shadow .12s ease, opacity .12s ease;
  }
  .btn:active{transform:translateY(1px) scale(.995)}
  .btn.secondary{
    background:transparent;
    color:white;
    border:1px solid rgba(255,255,255,0.14);
    box-shadow:none;
  }

  /* center greeting */
  .greeting {
    position: absolute;
    left:50%;
    transform:translateX(-50%);
    top:8%;
    z-index:25;
    text-align:center;
    pointer-events:none;
    user-select:none;
  }
  .greeting h1{
    margin:0;
    font-size:36px;
    letter-spacing:1px;
    color:white;
    text-shadow:0 4px 30px rgba(0,0,0,0.3);
  }
  .greeting p{margin:6px 0 0 0;color:rgba(255,255,255,0.9);font-size:15px}

  /* right-side calculator (glass) */
  .calculator {
    position: absolute;
    right: 36px;
    top: 50%;
    transform: translateY(-50%);
    width: 300px;
    padding: 16px;
    border-radius: 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: 0 10px 40px rgba(3,12,30,0.45);
    z-index:85;
    display:flex;
    flex-direction:column;
    gap:10px;
    pointer-events:auto;
    backdrop-filter: blur(8px) saturate(120%);
  }
  .calc-header{display:flex;justify-content:space-between;align-items:center}
  .calc-title{color:white;font-weight:700;font-size:16px}
  .calc-toggle{background:transparent;border:1px solid rgba(255,255,255,0.06);color:white;padding:6px 8px;border-radius:8px;cursor:pointer}
  .calc-screen {
    width:100%;
    height:54px;
    border-radius:10px;
    background:rgba(255,255,255,0.04);
    border:1px solid rgba(255,255,255,0.03);
    color:white;
    font-size:22px;
    padding:8px 12px;
    display:flex;
    align-items:center;
    justify-content:flex-end;
    box-shadow:inset 0 -6px 18px rgba(0,0,0,0.35);
  }
  .calc-keys {display:grid; grid-template-columns:repeat(4,1fr); gap:8px;}
  .k {
    padding:10px;
    font-size:16px;
    border-radius:8px;
    border:none;
    cursor:pointer;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    color:#f4f7ff;
    box-shadow: 0 6px 18px rgba(10,20,40,0.25);
  }
  .k.action{background:linear-gradient(180deg,#ff6b6b,#ff5a5a)}
  .k.equal{background:linear-gradient(180deg,#57d4a8,#3bc48d); font-weight:700}
  .k:active{transform:translateY(1px) scale(.997)}

  /* small note / instruction panel */
  .note {
    position:absolute;
    left:20%;
    bottom:24px;
    transform:translateX(-50%);
    color:rgba(255,255,255,0.9);
    z-index:20;
    pointer-events:none;
    font-size:13px;
    text-shadow:0 2px 6px rgba(0,0,0,0.25);
  }

  /* glowing cursor shadow: DOM element added and positioned */
  #cursorGlow {
    position: fixed;
    width: 140px;
    height: 140px;
    border-radius: 50%;
    pointer-events: none;
    background: radial-gradient(circle at 40% 30%, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.25) 12%, rgba(255,255,255,0.06) 30%, transparent 60%);
    filter: blur(30px);
    opacity: 0.85;
    transform: translate(-9999px,-9999px);
    z-index:22;
    transition: transform .06s linear;
  }

  /* footer small help */
  .footer {
    position:absolute;
    right:18px;
    bottom:18px;
    color:rgba(255,255,255,0.9);
    font-size:13px;
    z-index:20;
  }

  /* responsive adjustments */
  @media (max-width:800px){
    .calculator{right:12px; width:260px}
    .greeting h1{font-size:26px}
    .note{display:none}
  }

  /* night overlay for night-mode */
  .night-overlay {
    position:absolute;
    left:0; top:0; right:0; bottom:0;
    background: linear-gradient(180deg, rgba(12,18,40,0.0) 0%, rgba(7,12,25,0.0) 50%, rgba(2,6,12,0.35) 100%);
    pointer-events:none;
    z-index:14;
    transition:opacity 1s ease;
    opacity:0;
    mix-blend-mode: multiply;
  }

  /* canvas container to keep stacking order */
  canvas{ display:block; position:absolute; left:50%; transform:translateX(-50%); bottom:40px; z-index:10; border-radius:10px }
  /* small subtle ground shadow line */
  #groundLine { position:absolute; left:0; right:0; bottom:26px; height:2px; background:linear-gradient(90deg, rgba(0,0,0,0), rgba(0,0,0,0.22), rgba(0,0,0,0)); z-index:11; pointer-events:none }
</style>
</head>
<body>
  <div id="root">
    <!-- Top controls -->
    <div class="topbar">
      <button class="btn" id="toggleCalcBtn">Toggle Calculator</button>
      <button class="btn secondary" id="resetScene">Reset Scene</button>
      <button class="btn secondary" id="clearBalls">Clear Balls</button>
    </div>

    <!-- Center greeting -->
    <div class="greeting">
      <h1>Hello, I'm Arash ðŸ‘‹</h1>
      <p>Move your mouse to aim the cannon â€” click anywhere to shoot glowing balls. Enjoy the visuals!</p>
    </div>

    <!-- Calculator -->
    <div class="calculator" id="calculator" aria-hidden="false">
      <div class="calc-header">
        <div class="calc-title">Calculator</div>
        <button class="calc-toggle" id="hideCalc">Hide</button>
      </div>
      <div class="calc-screen" id="calcScreen">0</div>
      <div class="calc-keys" id="calcKeys">
        <button class="k" onclick="pressKey('7')">7</button>
        <button class="k" onclick="pressKey('8')">8</button>
        <button class="k" onclick="pressKey('9')">9</button>
        <button class="k" onclick="pressKey('/')">Ã·</button>

        <button class="k" onclick="pressKey('4')">4</button>
        <button class="k" onclick="pressKey('5')">5</button>
        <button class="k" onclick="pressKey('6')">6</button>
        <button class="k" onclick="pressKey('*')">Ã—</button>

        <button class="k" onclick="pressKey('1')">1</button>
        <button class="k" onclick="pressKey('2')">2</button>
        <button class="k" onclick="pressKey('3')">3</button>
        <button class="k" onclick="pressKey('-')">âˆ’</button>

        <button class="k" onclick="pressKey('0')">0</button>
        <button class="k" onclick="pressKey('.')">.</button>
        <button class="k equal" onclick="pressKey('=')">=</button>
        <button class="k" onclick="pressKey('+')">+</button>

        <button class="k action" style="grid-column:span 3" onclick="pressKey('C')">Clear</button>
        <button class="k" onclick="pressKey('H')">Home</button>
      </div>
    </div>

    <!-- cursor glow element -->
    <div id="cursorGlow"></div>

    <!-- night overlay -->
    <div class="night-overlay" id="nightOverlay"></div>

    <!-- ground line -->
    <div id="groundLine"></div>

    <!-- help note -->
    <div class="note">Tip: Move your mouse to aim. Click to shoot. Use the Toggle Calculator button to show/hide the calculator.</div>

    <!-- footer small -->
    <div class="footer">Built for Arash â€” Visual & Interaction Playground</div>

    <!-- main canvas: physics + visuals -->
    <canvas id="mainCanvas" width="1100" height="520" aria-label="Visual playground canvas"></canvas>
  </div>

<script>
/* --------------------------------------------
   Visual & Interaction Playground Script
   - responsive canvas
   - parallax background layers
   - fireflies particles
   - cannon aiming with mouse
   - click to shoot balls with trails & explosion particles
   - cursor glow follows mouse smoothly
   - night mode on idle
   - calculator logic & toggle
   -------------------------------------------- */

(() => {
  // quick utility
  function rand(min, max){ return Math.random()*(max-min)+min }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)) }

  // DOM references
  const canvas = document.getElementById('mainCanvas');
  const ctx = canvas.getContext('2d');
  const root = document.getElementById('root');
  const cursorGlow = document.getElementById('cursorGlow');
  const nightOverlay = document.getElementById('nightOverlay');
  const calcEl = document.getElementById('calculator');
  const toggleCalcBtn = document.getElementById('toggleCalcBtn');
  const hideCalc = document.getElementById('hideCalc');
  const resetScene = document.getElementById('resetScene');
  const clearBallsBtn = document.getElementById('clearBalls');
  const calcScreen = document.getElementById('calcScreen');

  // device pixel ratio for crisp canvas
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // state
  let W = 1100, H = 520;
  let lastTime = performance.now();
  let mouse = { x: W/2, y: H/2, vx:0, vy:0, down:false };
  let lastMoveTS = Date.now();
  let idleTS = Date.now();
  let balls = [];       // bullets shot from cannon
  let particles = [];   // explosion particles
  let fireflies = [];   // floating particles in the sky
  let trails = [];      // trailing dots for ball trails (optional small array)
  let parallaxOffset = { x:0, y:0 };

  // cannon
  const cannon = {
    x: W/2,
    y: H - 60,
    angle: -Math.PI/4,
    length: 46,
    radius: 18
  };

  // colors for balls
  const ballColors = ['#ffffff','#fff6e6','#bff7ff','#ffd6f5','#b9ffde'];

  // responsive canvas sizing
  function resizeCanvas(){
    // choose width relative to viewport
    const maxW = Math.min(window.innerWidth - 80, 1200);
    const computedW = Math.max(700, maxW);
    const computedH = Math.min(520, Math.max(420, window.innerHeight - 180));

    W = Math.floor(computedW);
    H = Math.floor(computedH);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    // reposition cannon
    cannon.x = W/2;
    cannon.y = H - 60;
  }

  // init fireflies
  function initFireflies(n=28){
    fireflies = [];
    for(let i=0;i<n;i++){
      fireflies.push({
        x: rand(40, W-40),
        y: rand(40, H/2),
        r: rand(1.6, 3.6),
        speed: rand(0.02, 0.12),
        phase: rand(0, Math.PI*2),
        hue: rand(180,320),
        drift: rand(-0.12,0.12)
      });
    }
  }

  // ball class
  function createBall(x,y,vx,vy,r=10,color='#fff'){
    return { x,y,vx,vy,r, color, trail:[], life:0 };
  }

  // particle for explosion
  function createParticle(x,y,angle,speed,color){
    return {
      x, y,
      vx: Math.cos(angle)*speed + rand(-0.6,0.6),
      vy: Math.sin(angle)*speed + rand(-0.6,0.6),
      life: 60 + Math.floor(rand(0,40)),
      age:0,
      r: rand(1,3),
      color
    };
  }

  // spawn explosion at coords
  function spawnExplosion(x,y, count=28, color='#fff6a8'){
    for(let i=0;i<count;i++){
      const ang = rand(0, Math.PI*2);
      const sp = rand(1.4, 6.2);
      particles.push(createParticle(x, y, ang, sp, color));
    }
  }

  // trails: we simply store small previous positions in ball.trail

  // update physics
  function updatePhysics(dt){
    // gravity constant
    const gravity = 0.45;
    // update balls
    for(let i=balls.length-1;i>=0;i--){
      const b = balls[i];
      // gravity
      b.vy += gravity * dt;
      // air drag
      b.vx *= (1 - 0.002*dt);
      b.vy *= (1 - 0.0009*dt);

      b.x += b.vx * dt;
      b.y += b.vy * dt;

      b.life += dt;

      // add trail point occasionally
      if(b.life % 2 < 0.5){
        b.trail.push({ x:b.x, y:b.y, t: 50 });
        if(b.trail.length > 20) b.trail.shift();
      }

      // bounce on ground
      if(b.y + b.r > H - 18){
        b.y = H - 18 - b.r;
        // reflect
        b.vy *= -0.62;
        b.vx *= 0.82;
        // spawn small explosion / sparks
        spawnExplosion(b.x, H - 18, 8, '#ffffff');
        // if speed small, stop (remove after small time)
        if(Math.abs(b.vy) < 0.8 && Math.abs(b.vx) < 0.6){
          // leave it on ground and fade
          b.vx *= 0.2;
          b.vy = 0;
          // slight rolling friction
          if(Math.abs(b.vx) < 0.08){
            // eventually remove after some time
            b.settle = (b.settle || 0) + dt;
            if(b.settle > 500){
              // small puff then remove
              spawnExplosion(b.x, b.y, 8, '#dff6ff');
              balls.splice(i,1);
              continue;
            }
          }
        }
      }

      // remove if off right/left and not visible
      if(b.x < -80 || b.x > W + 80 || b.y > H + 200){
        balls.splice(i,1);
      }
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.vy += 0.12 * dt; // mild gravity
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.age += dt;
      p.r *= 0.995;
      if(p.age > p.life) particles.splice(i,1);
    }

    // update fireflies
    for(let i=0;i<fireflies.length;i++){
      const f = fireflies[i];
      f.phase += f.speed * dt * 0.06;
      f.x += f.drift * dt;
      // keep in bounds
      if(f.x < 20) f.x = W - 40;
      if(f.x > W - 20) f.x = 40;
      // gentle y bobbing
      f.y += Math.sin(f.phase) * f.speed * 0.8 * dt;
    }

    // trails fade
    for(let i=balls.length-1;i>=0;i--){
      const b = balls[i];
      for(let j=b.trail.length-1;j>=0;j--){
        b.trail[j].t -= dt;
        if(b.trail[j].t <= 0) b.trail.splice(j,1);
      }
    }
  }

  // draw background with parallax, gradient and some layered clouds-like shapes
  function drawBackground(t){
    // sky gradient
    const topColor = lerpColor('#bfe9ff', '#6fb7f9', t.bgMix);
    const midColor = lerpColor('#83d6ff', '#6fb7f9', t.bgMix*0.7);
    const botColor = lerpColor('#6aa9ff', '#3f66b2', t.bgMix*0.55);

    // create gradient fill
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, topColor);
    g.addColorStop(0.45, midColor);
    g.addColorStop(1, botColor);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // subtle parallax shapes (soft blobs)
    for(let i=0;i<3;i++){
      ctx.save();
      const size = (i+1)*420;
      const x = (Math.sin(t.time * 0.0008 + i*1.2) * 40) + parallaxOffset.x * (i*0.02);
      const y = 80 + i*40 + parallaxOffset.y * (i*0.03);
      ctx.globalAlpha = 0.08 + i*0.02;
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      drawSoftBlob(ctx, W*0.5 + x, y, size, size*0.6, 6 + i*2);
      ctx.restore();
    }
  }

  // soft blob utility: draws layered radial shapes
  function drawSoftBlob(ctx, ox, oy, w, h, steps){
    for(let s=0;s<steps;s++){
      const alpha = (1 - s/steps) * 0.35;
      ctx.beginPath();
      ctx.ellipse(ox + Math.sin(s)*18, oy + Math.cos(s)*14, w*(0.8 - s/steps*0.5), h*(0.9 - s/steps*0.6), 0, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fill();
    }
  }

  // draw fireflies
  function drawFireflies(){
    for(let i=0;i<fireflies.length;i++){
      const f = fireflies[i];
      // glow
      const grad = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, 30);
      grad.addColorStop(0, `hsla(${f.hue},95%,70%,0.95)`);
      grad.addColorStop(0.3, `hsla(${f.hue},95%,60%,0.4)`);
      grad.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r*5 + Math.abs(Math.sin(f.phase))*6, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  // draw cannon & aim
  function drawCannon(){
    // barrel
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    // rotate toward mouse
    const targetAngle = Math.atan2(mouse.y - cannon.y, mouse.x - cannon.x);
    // clamp angle so barrel points above ground only
    const clamped = clampAngle(targetAngle, -Math.PI + 0.3, -0.2); // keep angle reasonable
    // ease angle change
    cannon.angle += (clamped - cannon.angle) * 0.22;

    ctx.rotate(cannon.angle);
    // barrel shadow
    ctx.fillStyle = '#0d1622';
    roundRect(ctx, -6, -12, cannon.length+26, 24, 12);
    ctx.fill();
    // barrel front
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.06;
    roundRect(ctx, cannon.length-6, -10, 30, 20, 10);
    ctx.globalAlpha = 1;

    // barrel gradient
    const brgrad = ctx.createLinearGradient(0,-12, cannon.length+26,12);
    brgrad.addColorStop(0, '#202b38');
    brgrad.addColorStop(0.5, '#3a5060');
    brgrad.addColorStop(1, '#11161d');
    ctx.fillStyle = brgrad;
    roundRect(ctx, -6, -10, cannon.length+26, 20, 10);
    ctx.fill();

    // muzzle flash hint when recently shot
    ctx.restore();

    // base
    ctx.beginPath();
    const baseRad = cannon.radius + 4;
    ctx.fillStyle = '#0b1420';
    ctx.arc(cannon.x, cannon.y, baseRad + 8, 0, Math.PI*2);
    ctx.fill();
    // lighter disc
    ctx.beginPath();
    ctx.fillStyle = '#091018';
    ctx.arc(cannon.x, cannon.y, cannon.radius, 0, Math.PI*2);
    ctx.fill();

    // small highlight ring
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 2;
    ctx.arc(cannon.x, cannon.y, cannon.radius+6, 0, Math.PI*2);
    ctx.stroke();
  }

  // draw balls and trails
  function drawBalls(){
    for(let i=0;i<balls.length;i++){
      const b = balls[i];
      // draw trail
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      for(let j=0;j<b.trail.length;j++){
        const t = b.trail[j];
        const alpha = clamp(t.t/50,0,1) * 0.42;
        const rr = Math.max(1.6, (t.t/50)*6);
        const grad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, rr*4);
        grad.addColorStop(0, hexToRgba(b.color, alpha));
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(t.x, t.y, rr, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // main ball
      ctx.beginPath();
      ctx.fillStyle = b.color;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 28;
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  // draw particles
  function drawParticles(){
    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      const pAlpha = 1 - (p.age / p.life);
      ctx.globalAlpha = pAlpha;
      ctx.beginPath();
      ctx.fillStyle = p.color;
      ctx.arc(p.x, p.y, Math.max(0.6, p.r * (1 - p.age/p.life)), 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      // small glow
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = hexToRgba(p.color, pAlpha*0.2);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r*6, 0, Math.PI*2);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
    }
  }

  // main render loop
  let FRAME = 0;
  const tState = { time:0, bgMix:0 };
  function render(now){
    const dt = Math.min(40, now - lastTime) / 16.666; // normalized to ~60fps scale
    lastTime = now;
    FRAME++;

    // time state mixing for day/night background
    tState.time = now;
    // if idle (no movement) gradually increase bgMix for night
    const idleDuration = Date.now() - lastMoveTS;
    const nightTarget = clamp((idleDuration - 6000) / 8000, 0, 1); // after ~6s starts fading in, reaches full ~14s
    tState.bgMix += (nightTarget - tState.bgMix) * 0.03;

    // parallax offset based on mouse
    parallaxOffset.x += ( (mouse.x - W/2) * 0.02 - parallaxOffset.x ) * 0.06;
    parallaxOffset.y += ( (mouse.y - H/2) * 0.02 - parallaxOffset.y ) * 0.06;

    // update physics
    updatePhysics(dt);

    // draw background
    drawBackground(tState);

    // draw some ground gradient and fog
    drawGroundAndFog();

    // draw fireflies (over background)
    drawFireflies();

    // draw cannon and balls and particles
    drawBalls();
    drawParticles();

    drawCannon();

    // overlay night (alpha based on bgMix)
    nightOverlay.style.opacity = tState.bgMix * 0.85;

    // update cursor glow - done in mouse move too for smoothness
    // (we keep DOM element for smooth blur and CSS performance)

    requestAnimationFrame(render);
  }

  // helper: linear interpolation of two colors given 0..1
  function lerpColor(a,b,t){
    const ca = hexToRgb(a); const cb = hexToRgb(b);
    const r = Math.round(ca.r + (cb.r - ca.r) * t);
    const g = Math.round(ca.g + (cb.g - ca.g) * t);
    const bl = Math.round(ca.b + (cb.b - ca.b) * t);
    return `rgb(${r},${g},${bl})`;
  }

  // hex to rgba helper
  function hexToRgba(hex, alpha=1){
    const c = hex.replace('#','');
    const bigint = parseInt(c,16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return `rgba(${r},${g},${b},${alpha})`;
  }
  function hexToRgb(hex){
    const c = hex.replace('#','');
    const bigint = parseInt(c,16);
    return { r: (bigint>>16)&255, g: (bigint>>8)&255, b: bigint&255 };
  }

  // clamp angle between min and max (handles wrap)
  function clampAngle(a, min, max){
    // normalize a to -PI..PI
    while(a > Math.PI) a -= Math.PI*2;
    while(a < -Math.PI) a += Math.PI*2;
    if(min < -Math.PI) min += Math.PI*2;
    if(max > Math.PI) max -= Math.PI*2;
    return Math.max(min, Math.min(max, a));
  }

  // roundRect helper
  function roundRect(ctx, x, y, w, h, r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
  }

  // draw ground & fog / subtle ground gradient
  function drawGroundAndFog(){
    // subtle ground rect
    const groundH = 36;
    const gy = H - groundH;
    const grd = ctx.createLinearGradient(0, gy, 0, H);
    grd.addColorStop(0, 'rgba(12,19,35,0.16)');
    grd.addColorStop(1, 'rgba(6,9,18,0.8)');
    ctx.fillStyle = grd;
    ctx.fillRect(0, gy, W, groundH);

    // fog layer
    ctx.globalAlpha = 0.12;
    for(let i=0;i<3;i++){
      const w = W * (0.6 + i*0.2);
      const x = Math.sin(i*2.3 + FRAME*0.01) * 30 + (i-1)*40;
      const y = gy + 6 + i*6;
      drawSoftBlob(ctx, W/2 + x, y, w, 60, 5);
    }
    ctx.globalAlpha = 1;
  }

  // shot logic: click to spawn ball
  function spawnBallAtCannon(power=12){
    // compute initial vx vy from cannon.angle
    const speed = power * (0.9 + Math.random()*0.3);
    const sx = cannon.x + Math.cos(cannon.angle) * (cannon.length + 8);
    const sy = cannon.y + Math.sin(cannon.angle) * (cannon.length + 8);
    // slight randomness
    const vx = Math.cos(cannon.angle) * speed + rand(-0.6, 0.6);
    const vy = Math.sin(cannon.angle) * speed + rand(-0.6, 0.6);

    const color = ballColors[Math.floor(rand(0, ballColors.length))];
    const b = createBall(sx, sy, vx, vy, rand(8,12), color);
    balls.push(b);

    // muzzle flash particle
    for(let i=0;i<8;i++){
      particles.push(createParticle(sx, sy, cannon.angle + rand(-0.6,0.6), rand(1.8,5.6), '#ffd6a8'));
    }
  }

  // pointer & input handling
  function setupInput(){
    window.addEventListener('mousemove', (e)=>{
      // compute canvas-local coords
      const rect = canvas.getBoundingClientRect();
      const cx = (e.clientX - rect.left) * (canvas.width / rect.width) / DPR;
      const cy = (e.clientY - rect.top) * (canvas.height / rect.height) / DPR;
      // set mouse relative to canvas
      mouse.x = clamp(cx, 0, W);
      mouse.y = clamp(cy, 0, H);
      // update DOM cursor glow quickly
      cursorGlow.style.transform = `translate(${e.clientX - 70}px, ${e.clientY - 70}px)`;
      lastMoveTS = Date.now();
    });

    // on click -> shoot
    window.addEventListener('click', (ev)=>{
      // if user clicked on calculator or UI, don't shoot
      const target = ev.target;
      if(target.closest && (target.closest('.calculator') || target.closest('.topbar') || target.closest('.btn') || target.closest('.calc-toggle') || target.closest('button'))) {
        return;
      }
      spawnBallAtCannon(12 + Math.random()*3);
      // flash small screen hint
      bounceGreeting();
    });

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'c' || e.key === 'C'){ toggleCalc(); }
      if(e.key === ' ') { // space shoot
        spawnBallAtCannon(13);
      }
    });
  }

  // greeting bounce animation when shot (subtle)
  function bounceGreeting(){
    const el = document.querySelector('.greeting');
    el.style.transition = 'transform 0.25s cubic-bezier(.2,.9,.2,1)';
    el.style.transform = 'translateX(-50%) translateY(-6px) scale(1.01)';
    setTimeout(()=>{ el.style.transform = 'translateX(-50%) translateY(0) scale(1)'; }, 200);
  }

  // calculator logic
  let calcValue = '';
  let calcShown = true;
  function updateCalcScreen(){
    calcScreen.textContent = calcValue === '' ? '0' : calcValue;
  }
  window.pressKey = function(k){
    if(k === 'C'){ calcValue = ''; updateCalcScreen(); return; }
    if(k === 'H'){ calcValue = ''; updateCalcScreen(); return; }
    if(k === '=') { 
      try {
        // evaluate safely (still simple eval, keep it simple)
        // replace Ã— Ã· with * /
        const expr = calcValue.replace(/Ã—/g,'*').replace(/Ã·/g,'/');
        const res = Function('"use strict";return (' + expr + ')')();
        calcValue = String(res);
      } catch(e){
        calcValue = 'Error';
      }
      updateCalcScreen();
      return;
    }
    // normal char
    calcValue += k;
    updateCalcScreen();
  }

  function toggleCalc(){
    calcShown = !calcShown;
    calcEl.style.display = calcShown ? 'flex' : 'none';
  }

  // attach buttons
  toggleCalcBtn.addEventListener('click', toggleCalc);
  hideCalc.addEventListener('click', ()=>{ calcShown = false; calcEl.style.display = 'none'; });
  resetScene.addEventListener('click', ()=>{ balls = []; particles = []; initFireflies(28); });
  clearBallsBtn.addEventListener('click', ()=>{ balls = []; });

  // utility to clear everything
  function resetAll(){ balls=[]; particles=[]; fireflies=[]; initFireflies(28); }

  // cursor "idle" behaviour: shrink / expand
  let cursorActive = true;

  // simple animation to make cursor glow breathe a bit
  let glowPhase = 0;
  function animateCursor(){
    glowPhase += 0.03;
    const s = 1 + Math.sin(glowPhase) * 0.04;
    cursorGlow.style.transform += ` scale(${s})`;
    requestAnimationFrame(animateCursor);
  }

  // small helper to start rendering
  function start(){
    resizeCanvas();
    initFireflies(28);
    setupInput();
    lastTime = performance.now();
    requestAnimationFrame(render);
    // optional: small interval to update cursor DOM transform smoothing
    setInterval(()=>{ /* keep cursor alive for mobile fallback */ }, 1000);
  }

  // hex helper to lighten/darken
  function shade(color, percent){
    const f = parseInt(color.slice(1),16);
    const t = percent < 0 ? 0 : 255;
    const p = Math.abs(percent);
    const R = f>>16, G = f>>8&0x00FF, B = f&0x0000FF;
    return "#" + (0x1000000 + (Math.round((t-R)*p)+R)*0x10000 + (Math.round((t-G)*p)+G)*0x100 + (Math.round((t-B)*p)+B)).toString(16).slice(1);
  }

  // small helper for hexToRgba above already included

  // initial startup
  window.addEventListener('resize', ()=>{ resizeCanvas(); });
  resizeCanvas();
  start();

  // tiny UX: pointer cursor change over UI elements
  const uiEls = [document.querySelector('.topbar'), calcEl, document.querySelector('.greeting')];
  uiEls.forEach(u => {
    u && u.addEventListener('mouseenter', ()=>{ document.body.style.cursor = 'default'; });
    u && u.addEventListener('mouseleave', ()=>{ document.body.style.cursor = 'crosshair'; });
  });

  // helper: execute render loop after everything set
  // Render loop already scheduled in start()

  // small finishing touches:
  // Show/hide calculator on initial load
  calcEl.style.display = calcShown ? 'flex' : 'none';

})(); // IIFE end
</script>
</body>
</html>
